:py:mod:`ITR.target_validation`
===============================

.. py:module:: ITR.target_validation


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   ITR.target_validation.TargetProtocol




Attributes
~~~~~~~~~~

.. autoapisummary::

   ITR.target_validation.logger


.. py:data:: logger
   

   

.. py:class:: TargetProtocol(config: Type[ITR.configs.PortfolioAggregationConfig] = PortfolioAggregationConfig)

   This class validates the targets, to make sure that only active, useful 
   targets are considered. It then combines the targets with company-related 
   data into a dataframe where there's one row for each of the nine possible 
   target types (short, mid, long * S1+S2, S3, S1+S2+S3). 
   This class follows the procedures outlined by the target protocol that is 
   a part of the "Temperature Rating Methodology" (2024), which has been created 
   by CDP Worldwide and WWF International.

   :param config: A Portfolio aggregation config

   .. py:method:: process(self, targets: List[ITR.interfaces.IDataProviderTarget], companies: List[ITR.interfaces.IDataProviderCompany]) -> pandas.DataFrame

      Process the targets and companies, validate all targets and return a data frame that combines all targets and company data into a 9-box grid.

      :param targets: A list of targets
      :param companies: A list of companies
      :return: A data frame that combines the processed data


   .. py:method:: _validate(self, target: ITR.interfaces.IDataProviderTarget) -> bool

      Validate a target, meaning it should:

      * Have a valid type
      * Not be finished
      * A valid end year

      :param target: The target to validate
      :return: True if it's a valid target, false if it isn't


   .. py:method:: _validate_t_score(self, target: ITR.interfaces.IDataProviderTarget) -> bool

      Validate targets set using the CDP_WWF temperature scoing methodology
      :param target: The target to validate
      :return: True if it's a valid target, false if it isn't


   .. py:method:: _split_s1s2s3(self, target: ITR.interfaces.IDataProviderTarget) -> Tuple[ITR.interfaces.IDataProviderTarget, Optional[ITR.interfaces.IDataProviderTarget]]

      If there is a s1s2s3 scope, split it into two targets with s1s2 and s3

      :param target: The input target
      :return The split targets or the original target and None


   .. py:method:: _split_s1s2(self, target: ITR.interfaces.IDataProviderTarget) -> List[ITR.interfaces.IDataProviderTarget]

      Split the target into two targets, one for the S1 data and one for the S2 data.

      :param target: The target to potentially split.
      :return: A list containing (the original S1S2 target and) 
       the S1 target and the S2 target from the split.


   .. py:method:: _combine_s1_s2(self, target: ITR.interfaces.IDataProviderTarget)

      Check if there is an S2 target that matches this target exactly (if this is a S1 target) 
      and combine them into one target.

      :param target: The input target
      :return: The combined target (or the original if no combining was required)


   .. py:method:: _cover_s1_s2(self, target: ITR.interfaces.IDataProviderTarget) -> ITR.interfaces.IDataProviderTarget

      Set the S1 and S2 coverage of a S1+S2 target to the same value.
      :param target: The input target
      :return: The modified target (or the original if no modification was required)


   .. py:method:: _convert_s1_s2_into_combined(target: ITR.interfaces.IDataProviderTarget) -> ITR.interfaces.IDataProviderTarget
      :staticmethod:

      Convert a S1 or S2 target into a S1+S2 target.

      TODO - what is the incidence of targets where base_year_ghg_s2==0

      :param target: The input target
      :return: The converted target (or the original if no conversion was required)


   .. py:method:: _scale_reduction_ambition_by_boundary_coverage(target: ITR.interfaces.IDataProviderTarget) -> ITR.interfaces.IDataProviderTarget
      :staticmethod:

      Change in ITR method 1.5: all targets have their ambition scaled by their boundary coverage.
      :param target: The input target
      :return: The original target with a weighted reduction ambition, if so required


   .. py:method:: _assign_time_frame(target: ITR.interfaces.IDataProviderTarget) -> ITR.interfaces.IDataProviderTarget
      :staticmethod:

      Time frame is forward looking: target year - current year. 
          Less than 5y = short, 
          between 5 and 10 is mid, 
          more than 10 is long

      :param target: The input target
      :return: The original target with the time_frame field filled out (if so required)


   .. py:method:: _prepare_targets(self, targets: List[ITR.interfaces.IDataProviderTarget])

      logic
          - drop invalid targets
          - identifying the pure-S2 targets for later use
          - splitting s1s2s3 into s1s2 and s3
          - combining s1 and s2
          - assign target.reduction_ambition by considering target's boundary coverage

      :param targets:
      :return:


   .. py:method:: _find_target(self, row: pandas.Series, target_columns: List[str]) -> pandas.DataFrame

      Find the target that corresponds to a given row. If there are multiple targets available, filter them.

      :param row: The row from the data set that should be looked for
      :param target_columns: The columns to return
      :return: records from the input data, which contains company and target information, that meet specific criteria. For example, record of greatest emissions_in_scope


   .. py:method:: _find_s3_targets(self, target_data: pandas.DataFrame, target_columns: List[str]) -> pandas.DataFrame

      Find S3 target that correspond to the given row. Note that there may be more
      than one S3 target. We first look for the target with the latest confirmation date.
      Then check if there is more than one target with the same confirmation date.
      The method then returns all targets with the latest confirmation date.

      :param target_data: The target data
      :param target_columns: The columns to return
      :return: The target data that meet the criteria


   .. py:method:: group_targets(self)

      Group the targets and create the target grid (short, mid, long * s1s2, s3, s1s2s3).
      Group valid targets by category & filter multiple targets
      Input: a list of valid targets for each company:
      For each company:

      Group all valid targets based on scope (S1+S2 / S3 / S1+S2+S3) and time frame (short / mid / long-term)
      into 6 categories.

      For each category: if more than 1 target is available, filter based on the following criteria
      -- Latest vintage
      -- Highest boundary coverage
      -- Latest end year
      -- Target type: Absolute over intensity
      -- If all else is equal: average the ambition of targets



