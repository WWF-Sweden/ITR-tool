ITR.temperature_score
=====================

.. py:module:: ITR.temperature_score


Classes
-------

.. autoapisummary::

   ITR.temperature_score.ScenarioType
   ITR.temperature_score.EngagementType
   ITR.temperature_score.Scenario
   ITR.temperature_score.TemperatureScore


Module Contents
---------------

.. py:class:: ScenarioType(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   A scenario defines which scenario should be run.


   .. py:attribute:: TARGETS
      :value: 1



   .. py:attribute:: APPROVED_TARGETS
      :value: 2



   .. py:attribute:: HIGHEST_CONTRIBUTORS
      :value: 3



   .. py:attribute:: HIGHEST_CONTRIBUTORS_APPROVED
      :value: 4



   .. py:method:: from_int(value) -> Optional[ScenarioType]
      :staticmethod:



.. py:class:: EngagementType(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   An engagement type defines how the companies will be engaged.


   .. py:attribute:: SET_TARGETS
      :value: 1



   .. py:attribute:: SET_SBTI_TARGETS
      :value: 2



   .. py:method:: from_int(value) -> EngagementType
      :staticmethod:


      Convert an integer to an engagement type.

      :param value: The value to convert
      :return:



   .. py:method:: from_string(value: Optional[str]) -> EngagementType
      :staticmethod:


      Convert a string to an engagement type.

      :param value: The value to convert
      :return:



.. py:class:: Scenario

   A scenario defines the action the portfolio holder will take to improve its temperature score.


   .. py:attribute:: scenario_type
      :type:  Optional[ScenarioType]


   .. py:attribute:: engagement_type
      :type:  EngagementType


   .. py:method:: get_score_cap() -> float


   .. py:method:: get_default_score(default_score: float) -> float


   .. py:method:: from_dict(scenario_values: dict) -> Optional[Scenario]
      :staticmethod:


      Convert a dictionary to a scenario. The dictionary should have the following keys:

      * number: The scenario type as an integer
      * engagement_type: The engagement type as a string

      :param scenario_values: The dictionary to convert
      :return: A scenario object matching the input values or None, if no scenario could be matched



   .. py:method:: from_interface(scenario_values: Optional[ITR.interfaces.ScenarioInterface]) -> Optional[Scenario]
      :staticmethod:


      Convert a scenario interface to a scenario.

      :param scenario_values: The interface model instance to convert
      :return: A scenario object matching the input values or None, if no scenario could be matched



.. py:class:: TemperatureScore(time_frames: List[ITR.interfaces.ETimeFrames], scopes: List[ITR.interfaces.EScope], default_score: float = TemperatureScoreConfig.DEFAULT_SCORE, model: int = TemperatureScoreConfig.MODEL_NUMBER, scenario: Optional[Scenario] = None, aggregation_method: ITR.portfolio_aggregation.PortfolioAggregationMethod = PortfolioAggregationMethod.WATS, grouping: Optional[List] = None, config: Type[ITR.configs.TemperatureScoreConfig] = TemperatureScoreConfig)

   Bases: :py:obj:`ITR.portfolio_aggregation.PortfolioAggregation`


   This class provides a temperature score based on the climate goals.

   :param default_score: The temp score if a company is not found
   :param model: The regression model to use
   :param config: A class defining the constants that are used throughout this class. This parameter is only required
                   if you'd like to overwrite a constant. This can be done by extending the TemperatureScoreConfig
                   class and overwriting one of the parameters.


   .. py:attribute:: model
      :value: 1



   .. py:attribute:: c
      :type:  Type[ITR.configs.TemperatureScoreConfig]


   .. py:attribute:: scenario
      :type:  Optional[Scenario]
      :value: None



   .. py:attribute:: default_score
      :value: 3.4



   .. py:attribute:: time_frames


   .. py:attribute:: scopes


   .. py:attribute:: aggregation_method
      :type:  ITR.portfolio_aggregation.PortfolioAggregationMethod


   .. py:attribute:: grouping
      :type:  list
      :value: []



   .. py:attribute:: regression_model
      :value: None



   .. py:attribute:: s3_calculation_test
      :value: False



   .. py:method:: get_target_mapping(target: pandas.Series) -> Optional[str]

      Map the target onto an AR6 target (None if not available).

      :param target: The target as a row of a dataframe
      :return: The mapped AR6 target



   .. py:method:: get_annual_reduction_rate(target: pandas.Series) -> Optional[float]

      Get the annual reduction rate (or None if not available).
      From version 1.5 the annual reduction rate is calculated as a
      compund annual reduction rate, CAR.

      :param target: The target as a row of a dataframe
      :return: The annual reduction



   .. py:method:: get_regression(target: pandas.Series) -> Tuple[Optional[float], Optional[float]]

      Get the regression parameter and intercept from the model's output.

      :param target: The target as a row of a dataframe
      :return: The regression parameter and intercept



   .. py:method:: _merge_regression(data: pandas.DataFrame)

      Merge the data with the regression parameters from the CDP-WWF Warming Function.
      :param data: The data to merge
      :return: The data set, amended with the regression parameters



   .. py:method:: get_score(target: pandas.Series) -> Tuple[float, float]

      Get the temperature score for a certain target based on the annual reduction rate and the regression parameters.

      :param target: The target as a row of a data frame
      :return: The temperature score



   .. py:method:: aggregate_company_score(row: pandas.Series, company_data: pandas.DataFrame) -> Tuple[float, float, list]

      Get the aggregated temperature score and a temperature result, which indicates how much of the score is
      based on the default score for a certain company based on the emissions of company.

      :param company_data: The original data, grouped by company, time frame and scope category
      :param row: The row to calculate the temperature score for (if the scope of the row isn't s1s2s3,
      it will return the original score
      :return: The aggregated temperature score for a company



   .. py:method:: get_default_score(target: pandas.Series) -> int

      Get the temperature score for a certain target based on the annual reduction rate and the regression parameters.

      :param target: The target as a row of a dataframe
      :return: The temperature score



   .. py:method:: _prepare_data(data: pandas.DataFrame)

      Prepare the data such that it can be used to calculate the temperature score.

      :param data: The original data set as a pandas data frame
      :return: The extended data frame



   .. py:method:: _calculate_company_score(data)

      Calculate the combined s1s2s3 scores for all companies.

      :param data: The original data set as a pandas data frame
      :return: The data frame, with an updated s1s2s3 temperature score



   .. py:method:: calculate(data: Optional[pandas.DataFrame] = None, data_providers: Optional[List[TemperatureScore.calculate.data]] = None, portfolio: Optional[List[ITR.interfaces.PortfolioCompany]] = None)

      Calculate the temperature for a dataframe of company data. The columns in the data frame should be a combination
      of IDataProviderTarget and IDataProviderCompany.

      :param data: The data set (or None if the data should be retrieved)
      :param data_providers: A list of DataProvider instances. Optional, only required if data is empty.
      :param portfolio: A list of PortfolioCompany models. Optional, only required if data is empty.
      :return: A data frame containing all relevant information for the targets and companies



   .. py:method:: _get_aggregations(data: pandas.DataFrame, total_companies: int) -> Tuple[ITR.interfaces.Aggregation, pandas.Series, pandas.Series]

      Get the aggregated score over a certain data set. Also calculate the (relative) contribution of each company

      :param data: A data set, containing one row per company
      :return: An aggregated score and the relative and absolute contribution of each company



   .. py:method:: _get_score_aggregation(data: pandas.DataFrame, time_frame: ITR.interfaces.ETimeFrames, scope: ITR.interfaces.EScope) -> Optional[ITR.interfaces.ScoreAggregation]

      Get a score aggregation for a certain time frame and scope, for the data set as a whole and for the different
      groupings.

      :param data: The whole data set
      :param time_frame: A time frame
      :param scope: A scope
      :return: A score aggregation, containing the aggregations for the whole data set and each individual group



   .. py:method:: aggregate_scores(data: pandas.DataFrame) -> ITR.interfaces.ScoreAggregations

      Aggregate scores to create a portfolio score per time_frame (short, mid, long).

      :param data: The results of the calculate method
      :return: A weighted temperature score for the portfolio



   .. py:method:: cap_scores(scores: pandas.DataFrame) -> pandas.DataFrame

      Cap the temperature scores in the input data frame to a certain value, based on the scenario that's being used.
      This can either be for the whole data set, or only for the top X contributors.

      :param scores: The data set with the temperature scores
      :return: The input data frame, with capped scores



   .. py:method:: anonymize_data_dump(scores: pandas.DataFrame) -> pandas.DataFrame

      Anonymize the scores by deleting the company IDs, ISIN and renaming the companies .

      :param scores: The data set with the temperature scores
      :return: The input data frame, anonymized



   .. py:method:: _calculate_s1s2_score(data: pandas.DataFrame) -> pandas.DataFrame

      Calculate the combined S1S2 score each combination of company_id, time_frame and scope.
      If it was possible pÃ¥ calculate individual S1 and S2 scores, then we calculate the
      aggregated S1S2 score.

      :param data: The data to calculate the S1S2 score for.
      :return: The S1S2 score.



   .. py:method:: _aggregate_s3_score(data: pandas.DataFrame) -> pandas.DataFrame

      Aggregate Scope 3 category scores into a single score per company and time frame.

      Steps:
      1) Calculate the mean temperature score for `s3_category == CAT_15`.
      2) Remove original CAT_15 rows and append the mean CAT_15 score back to the data.
      3) For each company and time frame:
      a) If GHG data is available for all categories, calculate a weighted average.
      b) If not, calculate a simple average of the scores.
      4) Replace the original scores with the aggregated score.



