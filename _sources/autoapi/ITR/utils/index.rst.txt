:py:mod:`ITR.utils`
===================

.. py:module:: ITR.utils


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   ITR.utils.get_data_providers
   ITR.utils.get_company_data
   ITR.utils.get_targets
   ITR.utils._flatten_user_fields
   ITR.utils._make_id_map
   ITR.utils.dataframe_to_portfolio
   ITR.utils.check_sbti_validation
   ITR.utils.get_data
   ITR.utils.calculate



Attributes
~~~~~~~~~~

.. autoapisummary::

   ITR.utils.DATA_PROVIDER_MAP


.. py:data:: DATA_PROVIDER_MAP
   :annotation: :Dict[str, Type[ITR.data.DataProvider]]

   

.. py:function:: get_data_providers(data_providers_configs: List[dict], data_providers_input: List[str]) -> List[ITR.data.DataProvider]

   Determines which data provider and in which order should be used.

   :param data_providers_configs: A list of data provider configurations
   :param data_providers_input: A list of data provider names
   :return: a list of data providers in order.


.. py:function:: get_company_data(data_providers: list, company_ids: List[str]) -> List[ITR.interfaces.IDataProviderCompany]

   Get the company data in a waterfall method, given a list of companies and a list of data providers. This will go
   through the list of data providers and retrieve the required info until either there are no companies left or there
   are no data providers left.

   :param data_providers: A list of data providers instances
   :param company_ids: A list of company ids (ISINs)
   :return: A data frame containing the company data


.. py:function:: get_targets(data_providers: list, companies: list) -> List[ITR.interfaces.IDataProviderTarget]

   Get the targets in a waterfall method, given a list of companies and a list of data providers. This will go through
   the list of data providers and retrieve the required info until either there are no companies left or there are no
   data providers left.

   :param data_providers: A list of data providers instances
   :param companies: A list of companies. Each company should be a dict and contain a company_name and company_id field
   :return: A data frame containing the targets


.. py:function:: _flatten_user_fields(record: ITR.interfaces.PortfolioCompany)

   Flatten the user fields in a portfolio company and return it as a dictionary.

   :param record: The record to flatten
   :return:


.. py:function:: _make_id_map(df_portfolio: pandas.DataFrame) -> dict

   Create a mapping from company_id to ISIN and LEI (required for the SBTi matching).

   :param df_portfolio: The complete portfolio
   :return: A mapping from company_id to (ISIN, LEI) tuple


.. py:function:: dataframe_to_portfolio(df_portfolio: pandas.DataFrame) -> List[ITR.interfaces.PortfolioCompany]

   Convert a data frame to a list of portfolio company objects.

   :param df_portfolio: The data frame to parse. The column names should align with the attribute names of the
   PortfolioCompany model.
   :return: A list of portfolio companies


.. py:function:: check_sbti_validation(targets: List[ITR.interfaces.IDataProviderTarget], companies: List[ITR.interfaces.IDataProviderCompany]) -> List[ITR.interfaces.IDataProviderTarget]

   Loops through targets and sets the value of sbti_validated to True
   if the associated company's status of sbti_validated is True, otherwise False
   We need this information to correctly use the method's time frame exception.
   This column is dropped before merging with company data in the process method
   of target_validation.

   :param targets: A list of IDataProviderTarget instances
   :param companies: A list of IDataProviderCompany instances


.. py:function:: get_data(data_providers: List[ITR.data.DataProvider], portfolio: List[ITR.interfaces.PortfolioCompany]) -> pandas.DataFrame

   Get the required data from the data provider(s), validate the targets and return a 9-box grid for each company.

   :param data_providers: A list of DataProvider instances
   :param portfolio: A list of PortfolioCompany models
   :return: A data frame containing the relevant company-target data


.. py:function:: calculate(portfolio_data: pandas.DataFrame, default_score: float, aggregation_method: ITR.portfolio_aggregation.PortfolioAggregationMethod, grouping: Optional[List[str]], scenario: Optional[ITR.temperature_score.Scenario], time_frames: List[ITR.interfaces.ETimeFrames], scopes: List[ITR.interfaces.EScope], anonymize: bool, aggregate: bool = True) -> Tuple[pandas.DataFrame, Optional[ITR.interfaces.ScoreAggregations]]

   Calculate the different parts of the temperature score (actual scores, aggregations, column distribution).

   :param portfolio_data: The portfolio data, already processed by the target validation module
   :param default_score: The default score to use while calculating the temperature score
   :param aggregation_method: The aggregation method to use
   :param time_frames: The time frames that the temperature scores should be calculated for  (None to calculate all)
   :param scopes: The scopes that the temperature scores should be calculated for (None to calculate all)
   :param grouping: The names of the columns to group on
   :param scenario: The scenario to play
   :param anonymize: Whether to anonymize the resulting data set or not
   :param aggregate: Whether to aggregate the scores or not
   :return: The scores, the aggregations and the column distribution (if a


